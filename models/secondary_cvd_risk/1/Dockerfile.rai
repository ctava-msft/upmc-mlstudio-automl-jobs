FROM mcr.microsoft.com/azureml/mlflow-ubuntu20.04-py38-cpu-inference:latest

USER dockeruser

ARG MLFLOW_MODEL_NAME=LightGBM

# Conda is already installed
ENV CONDA_ENV_DIR=/opt/miniconda/envs

# Create a new conda environment and install the same version of the server
COPY ./conda_env_v_1_0_0.yml /tmp/conda.yaml
RUN conda env create -n userenv -f /tmp/conda.yaml && \
    SERVER_VERSION=$(pip show azureml-inference-server-http | grep Version | sed -e 's/.*: //') && \
    $CONDA_ENV_DIR/userenv/bin/pip install --no-cache-dir \
        azureml-inference-server-http==$SERVER_VERSION \
        pandas numpy scikit-learn \
        "werkzeug>=2.1.0" \
        python-dateutil

# Update environment variables to default to the new conda env
ENV AZUREML_CONDA_ENVIRONMENT_PATH="$CONDA_ENV_DIR/userenv"
ENV PATH="$AZUREML_CONDA_ENVIRONMENT_PATH/bin:$PATH"
ENV LD_LIBRARY_PATH="$AZUREML_CONDA_ENVIRONMENT_PATH/lib:$LD_LIBRARY_PATH"

# Provide a default model directory for local runs
ENV AZUREML_MODEL_DIR="/var/mlflow_resources"
ENV MLFLOW_MODEL_FOLDER=model

# Enable detailed logging for debugging
ENV AZUREML_LOG_LEVEL=DEBUG
ENV PYTHONPATH="${AZUREML_MODEL_DIR}:${PYTHONPATH}"

# Copy the model.pkl file to the container
COPY ./model.pkl /tmp/model.pkl

# Create a real MLflow model using the loaded model from model.pkl
# This version includes RAI dashboard compatible wrapper with predict_proba support
# Compatible with: RAIInsights, Error Analysis, Explanations
USER root
RUN mkdir -p ${AZUREML_MODEL_DIR} && \
    /opt/miniconda/envs/userenv/bin/python - <<'PY'
import os
import pickle
import mlflow
import pandas as pd
import numpy as np

# Load the model from the pkl file
with open('/tmp/model.pkl', 'rb') as f:
    loaded_model = pickle.load(f)

# Define feature names for the secondary CVD risk model
FEATURE_NAMES = [
    'AGE', 'SEX', 'RACE', 'RACE_LABEL', 'ETHNICITY', 'ETHNICITY_DETAILED',
    'ADMITDATE', 'PROC_DATE', 'DISCHARGEDATE', 'HOSPITAL', 'PROC_TYPE',
    'BMI_IP', 'SBP_FIRST', 'SBP_LAST', 'DBP_FIRST', 'DBP_LAST', 'HR_FIRST', 'HR_LAST',
    'CANCER_DX', 'ALZHEIMER_DX', 'NONSPECIFIC_MCI_DX', 'VASCULAR_COGNITIVE_IMPAIRMENT_DX',
    'NONSPECIFIC_COGNITIVE_DEFICIT_DX', 'CHF_HST', 'DIAB_HST', 'AFIB_HST', 'OBESE_HST',
    'MORBIDOBESE_HST', 'TIA_HST', 'CARDIOMYOPATHY_HST', 'TOBACCO_STATUS', 'TOBACCO_STATUS_LABEL',
    'ALCOHOL_STATUS', 'ALCOHOL_STATUS_LABEL', 'ILL_DRUG_STATUS', 'ILL_DRUG_STATUS_LABEL',
    'CCI_CHF', 'CCI_PERIPHERAL_VASC', 'CCI_DEMENTIA', 'CCI_COPD', 'CCI_RHEUMATIC_DISEASE',
    'CCI_PEPTIC_ULCER', 'CCI_MILD_LIVER_DISEASE', 'CCI_DM_NO_CC', 'CCI_DM_WITH_CC',
    'CCI_HEMIPLEGIA', 'CCI_RENAL_DISEASE', 'CCI_MALIG_NO_SKIN', 'CCI_SEVERE_LIVER_DISEASE',
    'CCI_METASTATIC_TUMOR', 'CCI_AIDS_HIV', 'CCI_TOTAL_SCORE',
    'ELIX_CARDIAC_ARRTHYTHMIAS', 'ELIX_CONGESTIVE_HEART_FAILURE', 'ELIX_VALVULAR_DISEASE',
    'ELIX_PULM_CIRC_DISORDERS', 'ELIX_PERIPH_VASC_DISEASE', 'ELIX_HYPERTENSION',
    'ELIX_PARALYSIS', 'ELIX_NEURO_DISORDERS', 'ELIX_COPD', 'ELIX_DIABETES_WO_CC',
    'ELIX_DIABETES_W_CC', 'ELIX_HYPOTHYROIDISM', 'ELIX_RENAL_FAILURE', 'ELIX_LIVER_DISEASE',
    'ELIX_CHRONIC_PEPTIC_ULCER_DISEASE', 'ELIX_HIV_AIDS', 'ELIX_LYMPHOMA',
    'ELIX_METASTATIC_CANCER', 'ELIX_TUMOR_WO_METASTATIC_CANCER', 'ELIX_RHEUMATOID_ARTHRITIS',
    'ELIX_COAGULATION_DEFICIENCY', 'ELIX_OBESITY', 'ELIX_WEIGHT_LOSS',
    'ELIX_FLUID_ELECTROLYTE_DISORDERS', 'ELIX_ANEMIA_BLOOD_LOSS', 'ELIX_DEFICIENCY_ANEMIAS',
    'ELIX_ALCOHOL_ABUSE', 'ELIX_DRUG_ABUSE', 'ELIX_PSYCHOSES', 'ELIX_DEPRESSION',
    'ELIX_AHRQ_SCORE', 'ELIX_VAN_WALRAVEN_SCORE',
    'MED_CURRENT_ASA', 'MED_CURRENT_STATIN', 'MED_CURRENT_LOW_STATIN', 'MED_CURRENT_MODERATE_STATIN',
    'MED_CURRENT_HIGH_STATIN', 'MED_CURRENT_BB', 'MED_CURRENT_AB', 'MED_CURRENT_CCB',
    'MED_CURRENT_ARB', 'MED_CURRENT_ZETIA', 'MED_CURRENT_PCSK9', 'MED_CURRENT_WARFARIN',
    'MED_CURRENT_DOAC', 'MED_CURRENT_COLCHICINE', 'MED_CURRENT_ARNI', 'MED_CURRENT_HYDRALAZINE',
    'MED_CURRENT_MRA', 'MED_CURRENT_SPIRONOLACTONE', 'MED_CURRENT_MEMORY_AGENT',
    'Y00_HGB_A1C', 'Y00_TRIGLYCERIDE', 'Y00_HDL', 'Y00_LDL', 'Y00_CHOLESTEROL', 'Y00_HSCRP',
    'LAST_MED_ENC_TYPE'
]

# Target column name for RAI dashboard
TARGET_COLUMN = 'CVD_RISK'

# Class labels for binary classification
CLASS_LABELS = ['No CVD Risk', 'CVD Risk']


class RAIModelWrapper(mlflow.pyfunc.PythonModel):
    """
    RAI Dashboard compatible model wrapper for Azure ML Responsible AI components.
    
    This wrapper is designed to work with:
    - rai_tabular_insight_constructor: Initializes RAI dashboard
    - rai_tabular_erroranalysis: Error analysis component
    - rai_tabular_explanation: Model explanation/interpretability component  
    - rai_tabular_insight_gather: Gathers all insights for dashboard
    
    Required attributes for RAI compatibility:
    - classes_: Array of class labels (for classification)
    - feature_names_in_: Array of feature names (for explanations)
    - n_features_in_: Number of input features
    
    Required methods:
    - predict(X): Returns class predictions
    - predict_proba(X): Returns probability scores per class
    """
    
    def __init__(self, model, feature_names=None):
        self.model = model
        
        # Feature names for explainability (SHAP, feature importance)
        self.feature_names = feature_names or FEATURE_NAMES
        self.feature_names_in_ = np.array(self.feature_names)
        self.n_features_in_ = len(self.feature_names)
        
        # Classification settings
        self.model_type = 'classification'
        self.task_type = 'classification'  # Used by RAI constructor
        
        # Class labels - required for Error Analysis and Fairness Analysis
        # Use integers for sklearn compatibility, with string labels for display
        self.classes_ = np.array([0, 1])  # Binary: 0=No Risk, 1=Risk
        self.class_names = CLASS_LABELS
        self.n_classes_ = 2
        
        # Check underlying model capabilities
        self._has_predict_proba = hasattr(model, 'predict_proba')
        self._has_feature_importances = hasattr(model, 'feature_importances_')
        
        # Copy feature importances if available (for explanation component)
        if self._has_feature_importances:
            self.feature_importances_ = model.feature_importances_
        
        print(f"RAI Model Wrapper initialized for Azure ML RAI Dashboard:")
        print(f"  - Underlying model type: {type(model).__name__}")
        print(f"  - Has native predict_proba: {self._has_predict_proba}")
        print(f"  - Has feature importances: {self._has_feature_importances}")
        print(f"  - Number of features: {self.n_features_in_}")
        print(f"  - Classes: {self.classes_}")
        print(f"  - Class names: {self.class_names}")
    
    def _prepare_dataframe(self, model_input):
        """
        Convert input to DataFrame with proper column names.
        Handles various input formats from RAI components.
        """
        if isinstance(model_input, pd.DataFrame):
            return model_input
        elif isinstance(model_input, dict):
            return pd.DataFrame(model_input)
        elif isinstance(model_input, np.ndarray):
            if model_input.ndim == 1:
                model_input = model_input.reshape(1, -1)
            return pd.DataFrame(model_input, columns=self.feature_names)
        elif isinstance(model_input, list):
            return pd.DataFrame(model_input, columns=self.feature_names)
        else:
            return pd.DataFrame(model_input)
    
    def _convert_predictions_to_int(self, predictions):
        """
        Convert boolean predictions to integer class labels.
        RAI components expect integer class labels (0, 1) not booleans.
        """
        if predictions.dtype == bool:
            return predictions.astype(int)
        elif predictions.dtype == object:
            # Handle string predictions
            return np.array([1 if p in [True, 'True', 1, '1'] else 0 for p in predictions])
        return predictions.astype(int)
    
    def predict(self, ctx_or_data, model_input=None):
        """
        Make predictions - returns integer class labels (0 or 1).
        
        This method supports both:
        - MLflow PythonModel interface: predict(ctx, model_input)
        - sklearn-style interface: predict(X) - used by RAI components
        
        Returns:
            numpy array of integer class predictions (0=No Risk, 1=Risk)
        """
        # Handle both calling conventions
        if model_input is None:
            # sklearn-style call: predict(X)
            data = ctx_or_data
        else:
            # MLflow-style call: predict(ctx, model_input)
            data = model_input
        
        try:
            print(f"DEBUG [predict]: Input type: {type(data)}")
            
            df = self._prepare_dataframe(data)
            print(f"DEBUG [predict]: DataFrame shape: {df.shape}")
            
            # Get predictions from underlying model
            result = self.model.predict(df)
            print(f"DEBUG [predict]: Raw result type: {type(result)}, dtype: {getattr(result, 'dtype', 'N/A')}")
            
            # Convert to integer class labels for RAI compatibility
            result = self._convert_predictions_to_int(result)
            print(f"DEBUG [predict]: Converted result shape: {result.shape}, dtype: {result.dtype}")
            
            return result
            
        except Exception as e:
            print(f"ERROR [predict]: {str(e)}")
            import traceback
            print(traceback.format_exc())
            raise
    
    def predict_proba(self, data):
        """
        Get prediction probabilities for each class.
        
        Required for RAI dashboard components:
        - Error Analysis: Uses probabilities to identify error patterns
        - Fairness Analysis: Compares probability distributions across cohorts
        - Model Overview: Probability calibration curves
        - Explanations: SHAP values for probability outputs
        
        Args:
            data: Input features (DataFrame, ndarray, or list)
        
        Returns:
            numpy array of shape (n_samples, 2) with probabilities
            Column 0: P(No CVD Risk)
            Column 1: P(CVD Risk)
        """
        try:
            print(f"DEBUG [predict_proba]: Input type: {type(data)}")
            
            df = self._prepare_dataframe(data)
            print(f"DEBUG [predict_proba]: DataFrame shape: {df.shape}")
            
            if self._has_predict_proba:
                # Use native predict_proba if available
                proba = self.model.predict_proba(df)
                print(f"DEBUG [predict_proba]: Native proba shape: {proba.shape}")
                
                # Ensure 2D output for binary classification
                if proba.ndim == 1:
                    proba = np.column_stack([1 - proba, proba])
                elif proba.shape[1] == 1:
                    proba = np.column_stack([1 - proba, proba])
            else:
                # Fallback: create pseudo-probabilities from predictions
                predictions = self.model.predict(df)
                predictions = self._convert_predictions_to_int(predictions)
                
                # Convert to probability-like format
                # For binary predictions, use high confidence (0.95/0.05)
                pred_float = predictions.astype(float)
                proba = np.column_stack([
                    np.where(pred_float == 0, 0.95, 0.05),  # P(No Risk)
                    np.where(pred_float == 1, 0.95, 0.05)   # P(Risk)
                ])
                print(f"DEBUG [predict_proba]: Fallback proba shape: {proba.shape}")
            
            # Ensure probabilities sum to 1
            proba = proba / proba.sum(axis=1, keepdims=True)
            
            return proba
            
        except Exception as e:
            print(f"ERROR [predict_proba]: {str(e)}")
            import traceback
            print(traceback.format_exc())
            raise
    
    def get_feature_names(self):
        """
        Return feature names for explainability components.
        Used by SHAP and other explanation methods.
        """
        return self.feature_names
    
    def get_params(self, deep=True):
        """
        Get parameters for this estimator.
        Required for sklearn compatibility with some RAI components.
        """
        return {
            'model': self.model,
            'feature_names': self.feature_names,
        }
    
    def __sklearn_tags__(self):
        """
        Return sklearn estimator tags for compatibility.
        """
        return {
            'binary_only': True,
            'requires_y': True,
            '_skip_test': True,
        }


# Create the RAI-compatible wrapper
rai_wrapper = RAIModelWrapper(loaded_model, FEATURE_NAMES)

# Save the model to the MLflow model directory
dst = os.path.join(os.environ["AZUREML_MODEL_DIR"], os.environ["MLFLOW_MODEL_FOLDER"])

# Create MLflow model signature for better documentation
from mlflow.models.signature import ModelSignature
from mlflow.types.schema import Schema, ColSpec

# Define input schema
input_schema = Schema([ColSpec("string" if col in ['RACE_LABEL', 'TOBACCO_STATUS_LABEL', 
    'ALCOHOL_STATUS_LABEL', 'ILL_DRUG_STATUS_LABEL', 'HOSPITAL', 'LAST_MED_ENC_TYPE',
    'ADMITDATE', 'PROC_DATE', 'DISCHARGEDATE'] else "double", col) 
    for col in FEATURE_NAMES])

# Define output schema
output_schema = Schema([ColSpec("long", "prediction")])

signature = ModelSignature(inputs=input_schema, outputs=output_schema)

# Save with MLflow including metadata for RAI dashboard
mlflow.pyfunc.save_model(
    path=dst, 
    python_model=rai_wrapper, 
    conda_env=None,
    signature=signature,
    metadata={
        # Model type and task information
        "model_type": "classification",
        "task_type": "classification",
        "task": "binary_classification",
        
        # Target information
        "target_column": TARGET_COLUMN,
        "target": TARGET_COLUMN,
        
        # Class information for RAI
        "classes": CLASS_LABELS,
        "class_labels": CLASS_LABELS,
        "n_classes": 2,
        
        # Feature information for explanations
        "feature_names": FEATURE_NAMES,
        "n_features": len(FEATURE_NAMES),
        
        # RAI compatibility flags
        "rai_compatible": True,
        "supports_error_analysis": True,
        "supports_explanations": True,
        "supports_fairness_analysis": True,
        "supports_model_overview": True,
        
        # Model details
        "underlying_model": type(loaded_model).__name__,
    }
)

print(f"RAI-compatible model saved to: {dst}")
print(f"Model is ready for use with Azure ML RAI Dashboard components:")
print(f"  - rai_tabular_insight_constructor")
print(f"  - rai_tabular_erroranalysis")
print(f"  - rai_tabular_explanation")
print(f"  - rai_tabular_insight_gather")
PY

RUN chown -R dockeruser:dockeruser ${AZUREML_MODEL_DIR}
USER dockeruser

EXPOSE 5001
CMD ["runsvdir", "/var/runit"]
